---
layout:     post
title:      Golang GC探究
subtitle:   GC机制解析
date:       2019-10-27
author:     Walnut
header-img: img/post-bg-keyboard.jpg
catalog: true
tags:
    - Go
    - GC
---

# Golang GC探究

## 内存泄漏

### 简介

内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过失型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。

随着计算机应用需求的日益增加，应用程序的设计与开发也相应的日臻复杂，开发人员在程序实现的过程中处理的变量也大量增加，如何有效进行内存分配和释放，防止内存泄漏的问题变得越来越突出。例如服务器应用软件，需要长时间的运行，不断的处理由客户端发出的请求，如果没有有效的内存管理，每处理一次请求信息就有一定的内存泄漏。这样不仅影响到服务器的性能，还可能造成整个系统的崩溃。因此，内存管理成为软件设计开发人员在设计中考虑的主要方面。

### 泄漏原因

在C语言中，从变量存在的时间生命周期角度上，把变量分为静态存储变量和动态存储变量两类。静态存储变量是指在程序运行期间分配了固定存储空间的变量，而动态存储变量是指在程序运行期间根据实际需要进行动态地分配存储空间的变量。

在内存中供用户使用的内存空间分为三部分：

- 程序存储区
- 静态存储区
- 动态存储区

程序中所用的数据分别存放在静态存储区和动态存储区中。

静态存储区数据在程序的开始就分配好内存区，在整个程序执行过程中它们所占的存储单元是固定的，在程序结束时就释放，因此静态存储区数据一般为全局变量。

动态存储区数据则是在程序执行过程中根据需要动态分配和动态释放的存储单元，动态存储数据有三类函数形参变量、局部变量和函数调用时的现场保护与返回地址。由于动态存储变量可以根据函数调用的需要，动态地分配和释放存储，大大提高了内存的使用效率，使得动态存储变量在程序中被广泛使用。

开发人员进行程序开发的过程使用动态存储变量时，不可避免地面对内存管理的问题。程序中动态分配的存储空间，在程序执行完毕后需要进行释放。没有释放动态分配的存储空间而造成内存泄漏，是使用动态存储变量的主要问题。



## 什么是垃圾回收？

曾几何时，内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指C/C++）中，程序员必须对内存小心的进行管理操作，控制内存的申请及释放，稍有不慎，就可能产生内存泄漏问题。

这种问题不易发现并且难以定位，一直成为困扰开发者的噩梦。如何解决这个头疼的问题，过去一般采用两种方法：

- 内存泄漏检查工具：这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄漏的代码段。然后检测工具难免有疏漏和不足，只能起到辅助作用。

- 智能指针：这是C++中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，使程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序员有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄漏。

为了解决这个问题，后来出发出来的几乎所有新语言，都引入了语言层面的自动内存管理——也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为**垃圾回收**

## 常见的垃圾回收方法

### 引用计数

这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个**引用计数**，当引用该对象的对象被销毁或更新时，被引用对象的引用计数自动减1，当被引用对象被创建或被赋值给其他对象时引用计数自动加1。当引用计数为0时，则立即回收对象。

这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，例如python。

**缺点**
- 频繁更新引用计数降低了性能。一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。
- 循环引用问题。当对象间发生循环引用时，引用链中的对象都无法得到释放。最明显的解决方法是避免产生循环引用。

### 标记-清楚（mark and sweep）

该方法分为两步，

1. **标记**从根变量开始迭代地遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；

2. 标记完成后进行**清除**操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。

这种方法解决了引用计数的不足，但是也有比较明显的问题；每次启动垃圾回收都会暂停当前所有的正常代码运行，回收使系统响应能力大大降低。

这个算法存在一个缺陷，就是STW问题，因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当作垃圾收集掉。

当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的GC时间这是不可容忍的。

### 三色标记法

三色标记法是传统Mark-Sweep的一个改进，它是一个并发的GC算法。

原理如下：

- 首先创建三个集合：白、灰、黑
- 将所有对象放入白色集合中
- 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合
- 之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
- 重复4直至灰色中无任何对象
- 通过write-barrier检测对象有变化，重复以上操作
- 收集所有白色对象（垃圾）

### 分代收集

在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个成为**代**的空间。新创建的对象存放在称为“新生代”中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。

新生代垃圾回收的速度非常快，比老生代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老生代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老生代。

## Go的垃圾回收方法

整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记，先stop the world，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理。

第一轮先扫描所有可达的内存对象，标记为灰色放入队列；第二轮可以恢复STW，将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可达的对象，即没有被引用的对象；

第二轮再次stop the world，将第二轮过程中新增对象申请的内存进行标记（灰色），这是使用了write barrier

## 实践经验

1.	go程序内存占用大的问题 。这个问题在我们对后台服务进行压力测试时发现，我们模拟大量的用户请求访问后台服务，这时各服务模块能观察到明显的内存占用上升。但是当停止压测时，内存占用并未发生明显的下降。花了很长时间定位问题，使用gprof等各种方法，依然没有发现原因。最后发现原来这是正常的。主要的原因有两个，一是go的垃圾回收有个触发阈值，这个阈值会随着每次内存使用变大而逐渐增大（如初始阈值是10MB则下一次就是20MB，再下一次就成为了40MB…），如果长时间没有触发gc，go会主动触发一次（2min）。高峰时内存使用量上去后，除非持续申请内存，靠阈值触发gc已经基本不可能，而是要等最多2min主动gc开始才能触发 gc。第二个原因是go语言在向系统交还内存时只是告诉系统这些内存不需要使用了，可以回收；同时操作系统会采取“拖延症”策略，并不是立即回收，而是等到系统内存紧张时才会开始回收这样该程序又重新申请内存时就可以获得极快的分配速度。

2.	gc时间长的问题。 对于对用户响应事件有要求的后端程序，golang gc时的stop the world简直是噩梦。所有的垃圾回收型语言都难免在gc时面临性能下降，对此我们对于应该尽量避免频繁创建临时堆对象（如&abc{}, new, make等）以减少垃圾收集时的扫描时间，对于需要频繁使用的临时对象考虑直接通过数组缓存进行重用；很多人采用cgo的方法自己管理内存而绕开垃圾收集，这种方法除非迫不得已个人是不推荐的（容易造成不可预知的问题），当然迫不得已的情况下还是可以考虑的，这招带来的效果还是很明显的~

3.	goroutine泄露的问题。 我们的一个服务需要处理很多长连接请求，实现时，对于每个长连接请求各开了一个读取和写入协程，全部采用endless for loop不停地处理收发数据。当连接被远端关闭后，如果不对这两个协程做处理，他们依然会一直运行，并且占用的channel也不会被释放…这里就必须十分注意，在不使用协程后一定要把他依赖的channel close并通过再协程中判断channel是否关闭以保证其退出。


